# 🎁 **일반적인 프로그래밍 원칙**

이번 chapter는 자바의 지역변수, 제어구조, 라이브러리, 데이터 타입, 리플렉션, 네이티브 메서드를 다룬다.

<br>

## **⭐️ 아이템 57 : 지역변수의 범위를 최소화하라**

### ***지역변수의 범위를 줄이는 가장 강력한 기법은 '가장 처음 쓰일 때 선언하기'다.***  

사용하려면 멀었는데, 미리 선언하면 코드에서 나쁜 냄새가 나고, 변수를 실제 사용하는 시점에서는 타입과 초기값이 생각 나지 않는다.  

### ***거의 모든 지역변수는 선언과 동시에 초기화해야 한다.***  

초기화에 필요한 정보가 충분하지 않다면 충분해질 때까지 선언을 미뤄야한다.  

try-catch문은 위 규칙에서 예외이다. 변수를 초기화하는 과정에서 예외를 던질 가능성이 있다면 try 블록 안에서 초기화하고, try 블록 바깥에서도 사용한다면 try블록 앞에 선언하자.  

반복문은 독특한 방식으로 변수 범위를 최소화해준다. 반복 변수의 값을 반복문이 종료된 이후에도 써야하는 상황이 아니라면 while문 보다 for문을 쓰는 편이 낫다.

### ***메서드를 작게 유지하고 한 가지 기능에 집중하자.***  
메서드를 가능한 기능별로 쪼개자.

<br>

## **⭐️ 아이템 58 : 전통적인 for 문보다는 for-each 문을 사용하라**

전통적인 for문은 반복자나 인덱스변수를 이용해서 반복한다. 이는 코드를 지저분하게 만들고 진짜 필요한 것은 원소들 뿐이기 때문에 for-each문을 사용하는 것이 좋다. 변수를 사용하지 않으니 코드도 깔끔해지고, 오류날 일도 없다. 

### ***for-each문을 사용할 수 없는 상황***
- 파괴적인 필터링 : 컬렉션을 순회하면서 원소를 제거하려면 반복자의 remove를 메서드를 호출해야한다. 자바 8이후에는 removeIf를 이용하면 순회하는 것을 피할 수 있을 것이다. 
- 변형 : 리스트나 배열을 순회하면서 원소의 값 혹은 전체를 교체해야 한다면 리스트의 반복자나 배열의 인덱스를 사용해야 한다.
- 병렬 반복 : 여러 컬렉션을 병렬로 순회해야한다면 인덱스를 사용해야 된다.

<br>

## **⭐️ 아이템 59 : 라이브러리를 익히고 사용하라**

java 프로그래머라면 최소한 ```java.lang, java.util, java.io```와 그 하위 패키지들에는 익숙해져야 한다. 그리고 기능을 구현할 때 라이브러리에 기능이 존재하다면 라이브러리의 기능을 이용하는 것이 좋다. 왠만하면 직접 구현한 기능보다는 좋을 것이 분명하기 때문이다.  
이렇게 표준 라이브러리를 사용하면 전문가의 경험을 활용 할 수 있게 된다. 

<br>

## **⭐️ 아이템 60 : 정확한 답이 필요하다면 float와 double은 피하라**

float와 double은 이진 부동소수점 연산에 쓰이며, 넓은 범위의 수를 빠르게 정밀한 '근사치'로 계산하도록 세심하게 설계 되었다. 따라서 정확한 결과가 필요하다면 사용하면 안된다. 특히나 ```float과 double은 금융관련 계산과는 맞지 않다.```  

금융과 관련된 계산에는 BigDecimal, int 혹은 long을 사용해라  
BigDecimal은 기본타입보다는 쓰기가 훨씬 불편하고, 훨씬 느리다. 하지만 반올림이나 18자리 이상의 수에는 BigDecimal을 사용하는게 좋다.

<br>

## **⭐️ 아이템 61 : 박싱된 기본 타입보다는 기본 타입을 사용하라**

기본 타입과 박싱된 기본 타입의 주된 차이는 크게 세 가지 이다. 
- 첫 번째, 기본 타입은 값만 가지고 있으나, 박싱된 기본타입은 값에 더해 identity를 갖는다. 즉 박싱된 기본타입은 두 인스턴스는 값이 같아도 서로 다르다고 식별될 수 있다. 
- 두 번째, 기본 타입의 값은 언제나 유효하나, 박싱된 기본 타입은 유효하지 않은 값, 즉 null을 가질 수 있다.
- 세 번째, 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다. 

### 박싱된 기본타입을 쓸 때 주의점
- 박싱된 기본 타입에 == 연산자를 사용하면 오류가 일어난다.
- 기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본타입의 박싱이 자동으로 풀린다. 
    - ```NullPointerExcetion을 주의하자```

### 박싱된 기본타입을 써야할 때 
- 컬렉션의 원소, 키, 값 으로 쓴다. 컬렉션은 기본타입을 담을 수 없으므로 어쩔 수 없이 박싱된 기본타입을 써야한다.
- 리플렉션을 통해 메서드를 호출할 때 박싱된 기본 타입을 사용해야 한다. 

<br>

## **⭐️ 아이템 62 : 다른 타입이 적절하다면 문자열 사용을 피하라**

String은 텍스트를 표현하도록 설계되었다. 하지만 프로그래머들은 의도와 다르게 다른 타입을 대신해 String으로 쓰는 경향이 있다.  

특히나 int, float, BigInteger와 같은 수치형이나 'true/false'와 같은 boolean을 대신해 String을 사용하지 말자.  
또한 상수를 열거할때 Enum을 쓰는 것이 좋다.  
더불어서 ```className + "#" + i.next();```와 같은 혼합 타입을 String으로 표현하는 것은 대체로 옳지 않다. 문자열을 파싱해야하고 귀찮고, 오류 가능성도 커진다.  
마지막으로 String은 권한을 표현하기에 적합하지 않다. 요즘에는 UUID와 같은 String으로 표현하기도 하지만 문자열 대신 위조할 수 없는 Key를 사용하면 해결된다.

<br>

## **⭐️ 아이템 63 : 문자열 연결은 느리니 주의하라**

문자열 연결 연산자(+)로 문자열 n개를 잇는 시간은 n제곱에 비례한다. 이유는 문자열은 불변이라서 두 문자열을 연결할 경우 양쪽의 내용을 모두 복사해야 하므로 성능 저하는 피할 수 없다.  

성능에 신경을 쓰고싶으면 String 대신 StringBuilder를 사용하자.

<br>

## **⭐️ 아이템 64 : 객체는 인터페이스를 사용해 참조하라**

**적합한 인터페이스만 있다면 매개변수뿐 아니라 반환값, 변수, 필드를 전부 인터페이스 타입으로 선언하자.**  

**인터페이스를 타입으로 사용하는 습관을 길러두면 프로그램이 훨씬 유연해질 것이다.**  
단, 주의할 점은 원래의 클래스가 인터페이스의 일반 규약 이외의 특별한 기능을 제공하며, 주변 코드가 이 기능에 기대어 동작한다면 새로운 클래스도 반드시 같은 기능을 제공해야 한다.  
예를 들어 LinkedHashSet이 따르는 순서 정책을 가정하고 동작하는 상황에서 이를 HashSet으로 바꾸면 문제가 될 수 있다. HashSet은 순서를 보장하지 않기 때문이다.  

**적당한 인터페이스가 없다면 당연히 클래스로 참조해야 한다.**
- String, BigInteger 같은 값 클래스는 여러가지로 구현된다고 생각하고 설계되지 않았기에 final인 경우가 많고 인터페이스가 별도로 존재하지 않는다. 
- 클래스 기반으로 작성된 프레임워크가 제공하는 객체들이 있다. 이런 경우라도 기반 클래스를 사용해 참조하는 게 좋다. OutputStream과 같은 java.io 패키지의 여러 클래스가 대표적이다. 
- 특별한 메서드를 제공하는 클래스들이다. 예를 들어 우선순위큐 PriorityQueue class는 Queue 인터페이스에는 없는 comparator 메서드를 제공한다.

적합한 인터페이스가 없다면 클래스의 계층구조 중 필요한 기능을 만족하는 가장 덜 구체적인(상위의)클래스 타입으로 사용하자.

<br>

## **⭐️ 아이템 65 : 리플렉션보다는 인터페이스를 사용하라**

자바의 리플렉션 기능은 런타임시점에 임의의 클래스에 접근할 수 있다. 이를 구현한 대표적인 예시는 Spring boot의 어노테이션들, DI컨테이너 기술, Junit, 인텔리제이 자동완성 등에서 사용된다.  

리플렉션을 이용하면 컴파일 단계에서 존재하지 않던 클래스도 이용할 수 있다는 장점이 있지만 단점은 명확하다.  
- 컴파일타임 타입 검사가 주는 이점을 하나도 누릴 수 없다. 
- 리플렉션을 이용하면 코드가 지저분하고 장황해진다. 
- 성능이 떨어진다.  

이러한 단점들 때문에 리플렉션은 제한된 형태로만 사용해야 단점을 피하고 이점만 취할 수 있다.  
보통 리플렉션의 가장 중요포인트는 Class 타입인데 Class 타입을 이용해 객체 생성에만 쓰고, 이렇게 만든 객체는 컴파일타임에 알 수 있는 인터페이스나 상위클래스로 형변환해 사용하자.

<br>

## **⭐️ 아이템 66 : 네이티브 메서드는 신중히 사용하라**

Java Native Interface(JNI)는 자바 프로그램이 네이티브 메서드를 호출하는 기술이다. 
- 레지스트리 같은 플랫폼 특화 기능을 사용한다.
- 네이티브 코드로 작성된 기존 라이브러리를 사용한다. 레거시 데이터를 사용하는 레거시 라이브러리가 그 예다.
- 성능 개선을 목적으로 성능에 결정적인 영향을 주는 영역만 따로 네이티브 언어로 작성한다.  

요즘의 자바는 성능을 개선할 목적으로 네이티브 메서드를 사용하는 것은 거의 권장하지 않는다.  

만약 네이티브 메서드를 사용하려면 한번 더 생각해보자. 네이티브 메서드가 성능을 개선해 주는 일은 많지 않다. 저수준 자원이나 네이티브 라이브러리를 사용해야만 해서 어쩔 수 없더라도 네이티브 코드는 최소한만 사용하고 철저히 테스트하자. 네이티브 코드 안에 숨은 단 하나의 버그가 애플리케이션 전체를 훼손할 수도 있다.

<br>

## **⭐️ 아이템 67 : 최적화는 신중히 하라**

빠른 프로그램을 작성하려 안달하지 말자. 좋은 프로그램을 작성하다 보면 성능은 따라 오게 마련이다. 하지만 시스템을 설계할 때, 특히 API, 네트워크 프로토콜, 영구 저장용 데이터 포맷을 설계할 때는 성능을 염두에 두어야 한다. 시스템 구현을 완료했다면 이제 성능을 측정해보라. 충분히 빠르면 그것으로 끝이다. 그렇지 않다면 프로파일러를 사용해 문제의 원인이 되는 지점을 찾아 최적화를 수행하라. 가장 먼저 어떤 알고리즘을 사용 했는지 살펴보자. 알고리즘을 잘못 골랐다면 다른 저수준 최적화는 아무리 해봐야 소용이 없다. 만족할 때까지 이 과정을 반복하고, 모든 변경 후에는 성능을 측정하라.

<br>

## **⭐️ 아이템 68 : 일반적으로 통용되는 명명 규칙을 따르라**
자바의 명명 규칙은 대부분 관용적으로 정해져있다. 이펙티브 자바에서 소개한 명명규칙 외에 우리 나라에서 일반적으로 통용되는 자바와 관련한 컨벤션은 [캠퍼스 핵데이 Java 코딩 컨벤션](https://naver.github.io/hackday-conventions-java/)에서 확인할 수 있다.
