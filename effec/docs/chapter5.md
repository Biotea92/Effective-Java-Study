# 🎁 **제네릭**
제네릭(generic)은 자바 5부터 사용할 수 있다. 제네릭을 사용하게 되면 컬렉션이 담을 수 있는 타입을 컴파일러에게 알려준다.  
그 효과로 컴파일러가 형변환 코드를 추가하여 안전하고 명확하게 프로그래밍을 할 수 있다.

- 제네릭 예시 ( List )
```java
public interface List<E> extends Collection<E> {
    int size();
    boolean isEmpty();
    //...
    Iterator<E> iterator();
    E get(int index);
}
```
위 인터페이스 처럼 클래스와 인터페이스 선언에 타입 매개변수가 쓰이면, 이를 **제네릭 클래스** 혹은 **제네릭 인터페이스**라 한다. 

List 인터페이스는 원소의 타입을 나타내는 타입 매개변수 ```E```를 받는다. 이런 제네릭 클래스와 제네릭 인터페이스를 통틀어 **제네릭 타입**이라고 한다.  

- **네이밍** : 보통 제네릭 타입은 'T'를 사용하는 것을 권장한다. 하지만 어떤 문자를 사용해도 된다.  

    - E : 요소 (Element, 자바 컬렉션에서 주로 사용됨)
    - K : 키
    - N : 숫자
    - T : 타입
    - V : 값
    - S,U,V : 두번 째, 세 번째, 네 번째에 선언된 타입

<br>

## **⭐️ 아이템 26 : 로 타입은 사용하지 말라**

각각의 제네릭 타입은 일련의 **매개변수화 타입**을 정의한다.  
```List<String>``` 에서 String은 정규 타입 매개 변수 E에 해당하는 실제 타입 매개변수이다.  

### 🤔 ***로 타입이란*** 

로 타입(raw type)은 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다. 
예를 들어 List<E>에서 로 타입은 ```List```이다.  
로 타입은 타입 선언에서 제네릭 타입 정보가 전부 지워진 것 처럼 동작한다.

```java
// Stamp 인스턴스만 취급하기를 기대한다.
private final Collection stamps = ...;

// 정상적으로 컴파일 되지만 unchecked call 경고를 뱉는다.
stamps.add(new Coin(...));

// 이후에 Collection에서 동전을 꺼내면서 형 변환시 예외가 발생된다. -> 컴파일 시점까지는 모른다.
```
가장 좋은 예외는 컴파일 시점에 발견되는 예외이다.  
위의 예는 런타임시 발생하기 때문에 에러를 잡기 힘들다.
```JAVA
// 타입 매개변수 선언
private final Collection<Stamp> stamps = ...;

// 컴파일 시 에러 
stamps.add(new Coin(...));
```

이렇게 로 타입을 쓰게 되면 제네릭이 안겨주는 타입 안정성과 표현력을 모두 잃게 된다.  
java에서 이렇게 쓸데 없는 로 타입을 만든 이유는 제네릭이 생기기 전의 코드들과의 호환성 때문에 만들어 놓았다. 또한 이런 호환성을 위한 제네릭 구현에는 소거(erasure)를 방식을 사용한다.  

List와 같은 로타입 대신 List<Object> 같은 매개변수화 타입은 사용해도 된다.

### ***📌 비 한정적 와일드 카드***
이 쯤 되면 원소의 타입을 몰라도 되는 로 타입을 쓰고 싶어 진다.
- 잘 못된 예시(로타입) - 안전하지 않다.
```JAVA
static int numElementsInCommon(Set s1, Set s2) {
    int result = 0;
    for (Object o1 : s1)
        if (s2.contains(o1))
            result++;
    return result;
}
```
- 옳은 예시 (비한정적 와일드 카드 타입) - 타입 안전하며 유연하다.
```JAVA
static int numElementsInCommon(Set<?> s1, Set<?> s2) {
    ...
}
``` 

### ***📌 로 타입을 써야할 때***
1. class 리터럴에는 로 타입을 써야 한다.
2. instanceof 연산자를 사용 할때는 로 타입을 써야한다. 
```java
if (o instanceof Set) { // 로타입
    Set<?> s = (Set<?>) o; // 와일드카드 타입
    // ...
}
```

### 📌 **용어 정리**

| 한글 용어         | 영문 용어                   | 예                                      |
|---------------|-------------------------|----------------------------------------|
| 매개변수화 타입      | parameterized type      | ```List<String>```                     |
| 실제 타입 매개변수    | actual type parameter   | ```String```                           |
| 제네릭 타입        | generic type            | ```List<E>```                          |
| 정규 타입 매개변수    | formal type parameter   | ```E```                                |
| 비한정적 와일드카드 타입 | unbounded wildcard type | ```List<?>```                          |
| 로 타입          | raw type                | ```List```                             |
| 한정적 타입 매개변수   | bounded type parameter  | ```<E extends Number>```               |
| 한정적 와일드카드 타입  | bounded wildcard type   | ```List<? extends Number>```           |
| 제네릭 메서드       | generic method          | ```static <E> List<E> asList(E[] a)``` |
| 타입 토큰         | type token              | ```String.class```                     |


<br>

## **⭐️ 아이템 27 : 비검사 경고를 제거하라**
제네릭을 사용하기 시작하면 수 많은 컴파일러 경고를 마주하게 된다.  
비검사 형변환 경고, 비검사 메서드 호출 경고, 비검사 매개변수화 가변인수 타입 경고, 비검사 변환 경고 등  

이번 아이템에서는 할 수 있는 한 모든 비검사 경고를 제거하도록 제시한다.  
모든 경고를 제거한다면 런타임에 ClassCastException이 발생하지 않고 타입 안정성을 가질 수 있다.

### 📌 **비검사 경고 제거 방법**
- 대부분의 비검사 경고  
    다이아몬드 연산자만 추가하면 해결된다.
```JAVA
Set<Lark> exaltation = new HashSet();
Set<Lark> exaltation = new HashSet<>();
```
- 경고를 제거할 수는 없지만 타입 안전하다고 확신할 수 있으면 ```@SuppressWarnings("unchecked")``` 애노테이션을 달아 경고를 숨기자
    - 꼭 타입이 안전함을 검증하고 어노테이션을 사용해야한다.
    - ```@SuppressWarnings("unchecked")```은 꼭 가능한 한 좁은 범위에 사용하자. 지역변수, 클래스 전체 어디든 달 수 있는 어노테이션이기 때문에 좁게 설정이 가능하다.
    - 어노테이션을 사용할 때 경고를 무시해도 안전한 이유를 항상 주석을 남겨라

<br>

## **⭐️ 아이템 28 : 배열보다는 리스트를 사용하라**
배열과 제네릭 타입에서는 중요한 차이가 두 가지 있다.  

### ***차이 1*** 
배열은 공변이다.  
제네릭은 불공변이다.  
다음 코드를 보면 공변과 불공변의 차이를 쉽게 이해할 수 있다.  
```java
/* 런타임에 실패한다 */
Object[] objectArray = new Long[1];
objectArray[0] = "타입이 달라 넣을 수 없다."; // ArrayStoreException 예외 발생

/* 컴파일되지 않는다. */
List<Object> ol = new ArrayList<Long>();
ol.add("타입이 달라 넣을 수 없다."); // 컴파일 오류 발생
```
배열은 하위 타입을 상위 타입 배열에 넣을 수 있지만, 제네릭은 불가능하다.  
두 코드 모두 Long용 저장소에 String을 넣을 수 없지만 에러를 알아 내는 시점이 다르기 때문에 리스트가 더 좋다.

### ***차이 2***
배열은 실체화된다. -> 배열은 런타임 시에도 자신이 담기로 한 언소 타입을 인지하고 확인하여 예외를 던진다.  
제네릭은 타입 정보가 런타임에는 소거(Erasure)된다.  

### 제네릭 배열 생성 오류
제네릭과 배열은 같이 어우러지지 못한다. 배열은 제네릭 타입, 매개변수화 타입, 타입 매개변수로 사용할 수 없다. ```new List<E>[]```, ```new List<String>[]```, ```new E[]```식으로 작성하면 컴파일할 때 제네릭 배열 생성 오류를 일으킨다.

<br>

## **⭐️ 아이템 29 : 이왕이면 제네릭 타입으로 만들라**

<br>

## **⭐️ 아이템 30 : 이왕이면 제네릭 메서드로 만들라**

<br>

## **⭐️ 아이템 31 : 한정적 와일드카드를 사용해 API 유연성을 높이라**

<br>

## **⭐️ 아이템 32 : 제네릭과 가변인수를 함께 쓸 때는 신중하라**
