# 🎁 **예외**

<br>

## **⭐️ 아이템 69 : 예외는 진짜 예외 상황에만 사용하라**

다음 두 코드를 보자 
```JAVA
try {
    int i = 0;
    while (true)
        range[i++].climb();
} catch (ArrayIndexOutOfBoundsException e) {
}
```
```java
for (Mountain m : range)
    m.climb();
```

두 코드 모두 같은 동작을 하는데 첫 번째는 예외를 이용해서 루프를 종료하였고, 두 번째는 배열의 끝에 도달하면 종료한다. 둘 다 같은 기능을 하지만 첫 번째 방법은 전혀 직관적이지 못하고 끔찍하다.  
이러한 문제는 세가지 관점에서 잘못되었다. 

1. 예외는 예외 상황에 쓸 용도로 설계되었으므로 JVM 구현자 입장에서는 명확한 검사만큼 빠르게 만들어야 할 동기가 약하다(최적화에 별로 신경 쓰지않았을 가능성이 크다.)
2. 코드를 try-catch 브록 안에 넣으면 JVM이 적용할 수 있는 최적화가 제한 된다.
3. 배열을 순회하는 표준 과뇽ㅇ구는 앞서 걱정한 중복 검사를 수행하지 않는다. JVM이 알아서 최적화해 없애준다.  

예외는 오직 예외 상황에서만 써야 한다. 절대로 일상적인 제어 흐름용으로 쓰여선 안 된다.  

잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야 한다.

<br>

## **⭐️ 아이템 70 : 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라**

<br>

## **⭐️ 아이템 71 : 필요 없는 검사 예외 사용은 피하라**

<br>

## **⭐️ 아이템 72 : 표준 예외를 사용하라**

<br>

## **⭐️ 아이템 73 : 추상화 수준에 맞는 예외를 던지라**

<br>

## **⭐️ 아이템 74 : 메서드가 던지는 모든 예외를 문서화하라**

<br>

## **⭐️ 아이템 75 : 예외의 상세 메시지에 실패 관련 정보를 담으라**

<br>

## **⭐️ 아이템 76 : 가능한 한 실패 원자적으로 만들라**

<br>

## **⭐️ 아이템 77 : 예외를 무시하지 말라**


